# 滑动窗口算法笔记

## 快速复盘总结

### 区间长度计算（重要！）

```
闭区间 [L, R]：元素数量 = R - L + 1
左闭右开 [L, R)：元素数量 = R - L
左开右闭 (L, R]：元素数量 = R - L
开区间 (L, R)：元素数量 = R - L - 1
```

**判断技巧**：
- 闭区间包含端点，所以 +1
- 开区间不包含端点，所以 -1
- 半开半闭刚好抵消，直接相减

**定长窗口 k 的左边界计算**：
```
闭区间 [left, right]，窗口大小 k：left = right - k + 1
左闭右开 [left, right)，窗口大小 k：left = right - k
```

### 核心要点

1. **定长窗口**：窗口大小固定，先入后出
2. **变长窗口**：用 `while` 收缩左边界直到满足条件
3. **窗口状态**：变量（计数/求和）、数组/HashMap（频次）、单调队列（最值）
4. **时间复杂度**：O(n)，每个元素最多入一次、出一次

### 模板选择

| 题型 | 模板 |
|------|------|
| 固定长度 k 的子数组/子串 | 定长窗口 |
| 满足条件的最长子数组/子串 | 变长窗口 + `while` 收缩 |
| 满足条件的最短子数组/子串 | 变长窗口 + `while` 收缩 |
| 滑动窗口内最大/最小值 | 定长窗口 + 单调队列 |

---

## 一、核心思想

滑动窗口是一种**双指针技巧**，通过维护一个窗口在数组/字符串上滑动，避免重复计算。

- **时间复杂度优化**：将暴力的 O(n²) 或 O(n×k) 优化到 O(n)
- **本质**：利用窗口的移动，只需要处理"新进入"和"离开"的元素，而不是重新计算整个窗口

```
数组: [1, 3, 2, 6, 4, 8, 3]
窗口大小 k=3

第一个窗口: [1, 3, 2] 6, 4, 8, 3   sum = 6
第二个窗口:  1,[3, 2, 6] 4, 8, 3   sum = 6 - 1 + 6 = 11  (不需要重新算 3+2)
第三个窗口:  1, 3,[2, 6, 4] 8, 3   sum = 11 - 3 + 4 = 12
```

---

## 二、两种类型

### 2.1 定长窗口（窗口大小固定为 k）

**适用场景**：
- 长度为 k 的子数组/子串的最大和、最大平均值
- 长度为 k 的子串中某元素的最大数量
- 所有长度为 k 的子数组中的最大/最小值

**模板代码**：

```java
public int slidingWindowFixed(int[] arr, int k) {
    int n = arr.length;
    int res = 0;
    
    for (int right = 0; right < n; right++) {
        // 1. 入：右边元素进入窗口，更新窗口状态
        add(arr[right]);
        
        // 2. 窗口还没满 k 个元素，继续扩展
        if (right < k - 1) {
            continue;
        }
        
        // 3. 计算：窗口已满，更新答案
        res = Math.max(res, calculate());
        
        // 4. 出：左边元素离开窗口，更新窗口状态
        int left = right - k + 1;
        remove(arr[left]);
    }
    
    return res;
}
```

**例题：LeetCode 1456 - 定长子串中元音的最大数目**

```java
public int maxVowels(String s, int k) {
    int res = 0;
    int cur = 0;  // 窗口状态：当前窗口内元音数量
    char[] cs = s.toCharArray();
    
    for (int right = 0; right < s.length(); right++) {
        // 入：右边字符进入窗口
        if (isVowel(cs[right])) {
            cur++;
        }
        
        // 窗口还没满
        if (right < k - 1) {
            continue;
        }
        
        // 计算答案
        res = Math.max(res, cur);
        if (res == k) return res;  // 剪枝优化
        
        // 出：左边字符离开窗口
        int left = right - k + 1;
        if (isVowel(cs[left])) {
            cur--;
        }
    }
    return res;
}

private boolean isVowel(char c) {
    return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u';
}
```

---

### 2.2 变长窗口（窗口大小不固定）

**适用场景**：
- 满足某条件的**最长**子数组/子串
- 满足某条件的**最短**子数组/子串
- 满足某条件的子数组/子串**数量**

**模板代码**：

```java
public int slidingWindowVariable(int[] arr) {
    int n = arr.length;
    int left = 0;
    int res = 0;
    
    for (int right = 0; right < n; right++) {
        // 1. 入：右边元素进入窗口
        add(arr[right]);
        
        // 2. 收缩：不满足条件时，收缩左边界
        while (不满足条件) {
            remove(arr[left]);
            left++;
        }
        
        // 3. 计算：此时窗口满足条件，更新答案
        // 求最长：res = Math.max(res, right - left + 1);
        // 求最短：res = Math.min(res, right - left + 1);
    }
    
    return res;
}
```

**例题：LeetCode 3 - 无重复字符的最长子串**

```java
public int lengthOfLongestSubstring(String s) {
    int[] cnt = new int[128];  // 窗口状态：字符出现次数
    int left = 0;
    int res = 0;
    
    for (int right = 0; right < s.length(); right++) {
        char c = s.charAt(right);
        // 入
        cnt[c]++;
        
        // 收缩：有重复字符时收缩
        while (cnt[c] > 1) {
            cnt[s.charAt(left)]--;
            left++;
        }
        
        // 计算
        res = Math.max(res, right - left + 1);
    }
    return res;
}
```

---

## 三、窗口状态的维护

窗口内部需要维护的"状态"取决于题目要求：

### 3.1 单个变量

**场景**：求和、计数

```java
int cur = 0;

// 入
cur += arr[right];  // 或 cur++

// 出
cur -= arr[left];   // 或 cur--
```

**适用题目**：
- 子数组最大和
- 定长子串中元音的最大数目

---

### 3.2 HashMap（哈希表）

**场景**：统计元素出现次数、判断是否满足某种频次条件

```java
Map<Character, Integer> map = new HashMap<>();

// 入
map.put(c, map.getOrDefault(c, 0) + 1);

// 出
int count = map.get(c);
if (count == 1) {
    map.remove(c);
} else {
    map.put(c, count - 1);
}
```

**适用题目**：
- 最小覆盖子串（LeetCode 76）
- 字母异位词（LeetCode 438）
- 最多 K 个不同字符的最长子串

---

### 3.3 计数数组（比 HashMap 更快）

**场景**：字符统计（字符集有限时）

```java
int[] cnt = new int[128];  // ASCII 字符
// 或 int[] cnt = new int[26];  // 只有小写字母

// 入
cnt[c]++;

// 出
cnt[c]--;
```

**适用题目**：
- 无重复字符的最长子串
- 替换后的最长重复字符

---

### 3.4 HashSet

**场景**：判断元素是否存在（不关心次数）

```java
Set<Character> set = new HashSet<>();

// 入
set.add(c);

// 出
set.remove(c);

// 判断
set.contains(c);
```

---

### 3.5 单调队列（Deque）

**场景**：滑动窗口内的最大值/最小值

```java
Deque<Integer> deque = new LinkedList<>();  // 存储下标

// 入：维护单调递减队列（求最大值）
while (!deque.isEmpty() && arr[deque.peekLast()] <= arr[right]) {
    deque.pollLast();
}
deque.offerLast(right);

// 出：如果队首元素已经不在窗口内，移除
if (deque.peekFirst() < left) {
    deque.pollFirst();
}

// 获取最大值
int max = arr[deque.peekFirst()];
```

**适用题目**：
- 滑动窗口最大值（LeetCode 239）

---

## 四、关键技巧

### 4.1 窗口边界计算

```
闭区间 [left, right]：
- 窗口长度 = right - left + 1
- 定长窗口：left = right - k + 1

半开区间 [left, right)：
- 窗口长度 = right - left
- 定长窗口：left = right - k
```

### 4.2 入和出的顺序

**定长窗口**：
```
入 → 判断窗口是否满 → 计算 → 出
```

**变长窗口**：
```
入 → 收缩（while 循环出）→ 计算
```

### 4.3 常见剪枝

```java
// 已经找到最优解，提前返回
if (res == k) return res;

// 剩余元素不够，提前结束
if (n - right < need) break;
```

---

## 五、经典题目分类

| 类型 | 题目 | 难度 |
|------|------|------|
| 定长窗口 | 643. 子数组最大平均数 | Easy |
| 定长窗口 | 1456. 定长子串中元音的最大数目 | Medium |
| 定长窗口 | 239. 滑动窗口最大值 | Hard |
| 变长-最长 | 3. 无重复字符的最长子串 | Medium |
| 变长-最长 | 1004. 最大连续1的个数 III | Medium |
| 变长-最长 | 424. 替换后的最长重复字符 | Medium |
| 变长-最短 | 209. 长度最小的子数组 | Medium |
| 变长-最短 | 76. 最小覆盖子串 | Hard |
| 变长-计数 | 713. 乘积小于K的子数组 | Medium |

---

## 六、总结

1. **定长窗口**：窗口大小固定，用 `right - k + 1` 计算左边界
2. **变长窗口**：用 `while` 循环收缩左边界直到满足条件
3. **窗口状态**：根据题目选择合适的数据结构（变量、数组、HashMap、单调队列）
4. **核心操作**：入窗口更新状态，出窗口撤销状态
5. **时间复杂度**：O(n)，每个元素最多入窗口一次、出窗口一次
