# 动态规划笔记

## 核心思想

将复杂问题分解为重叠子问题，通过存储子问题的解避免重复计算。

---

## 解题步骤

1. **定义状态**：`dp[i]` 表示什么
2. **状态转移方程**：`dp[i]` 如何由之前的状态推导
3. **初始条件**：边界情况
4. **计算顺序**：从小到大递推

---

## 两种实现方式

### 1. 递推（自底向上）

```java
int[] dp = new int[n + 1];
dp[0] = base0;
dp[1] = base1;
for (int i = 2; i <= n; i++) {
    dp[i] = f(dp[i-1], dp[i-2], ...);
}
return dp[n];
```

### 2. 记忆化搜索（自顶向下）

```java
int[] memo = new int[n + 1];
Arrays.fill(memo, -1);

int dfs(int i) {
    if (i < 2) return base;
    if (memo[i] != -1) return memo[i];
    return memo[i] = f(dfs(i-1), dfs(i-2), ...);
}
```

---

## 经典题型

### 爬楼梯系列

| 题号 | 题目 | 状态定义 | 转移方程 |
|------|------|----------|----------|
| 70 | 爬楼梯 | `dp[i]` = 到第 i 阶的方案数 | `dp[i] = dp[i-1] + dp[i-2]` |
| 746 | 最小花费爬楼梯 | `dp[i]` = 到第 i 阶的最小花费 | `dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2])` |

---

## 空间优化

当状态只依赖前几个值时，可用滚动变量优化空间：

```java
// O(n) 空间
int[] dp = new int[n + 1];

// O(1) 空间（滚动变量）
int a = 0, b = 0;
for (int i = 2; i <= n; i++) {
    int c = Math.min(a + cost[i-2], b + cost[i-1]);
    a = b;
    b = c;
}
```
